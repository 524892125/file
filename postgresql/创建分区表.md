```postgresql
-- 1️⃣ 创建父表（HASH 分区）
CREATE TABLE public.event_user (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY,
    phone BIGINT CHECK (phone >= 0),
    username VARCHAR(255),
    create_time TIMESTAMP(6),
    update_time TIMESTAMP(6),
    avatar TEXT,
    PRIMARY KEY (id)
) PARTITION BY HASH (id);

-- 2️⃣ 创建 32 个 HASH 子分区
DO $$
BEGIN
    FOR i IN 0..31 LOOP
        EXECUTE format('
            CREATE TABLE public.event_user_part_%s PARTITION OF public.event_user
            FOR VALUES WITH (MODULUS 32, REMAINDER %s);
        ', i, i);
    END LOOP;
END$$;


修改为主键自增
ALTER TABLE event_user_detail
    ALTER COLUMN id ADD GENERATED ALWAYS AS IDENTITY;


CREATE TABLE public.event_reservation_user_address (
                                                       uid BIGINT NOT NULL,                -- 对应 int(10) unsigned（PostgreSQL 没有 unsigned，用 BIGINT 代替）
                                                       address TEXT,                       -- 直接使用 text
                                                       create_time TIMESTAMP(6),           -- 对应 datetime
                                                       update_time TIMESTAMP(6),
                                                       phone BIGINT,                       -- 对应 bigint(20) unsigned
                                                       name VARCHAR(255),
                                                       CONSTRAINT event_reservation_user_address_pkey PRIMARY KEY (uid)
);


写入的时候分区的问题

方案一（推荐）统一使用主表的序列

让所有分区表共享 同一个 sequence：

ALTER TABLE event_user_part_0 ALTER COLUMN id SET DEFAULT nextval('event_user_id_seq');
ALTER TABLE event_user_part_1 ALTER COLUMN id SET DEFAULT nextval('event_user_id_seq');
...
ALTER TABLE event_user_part_31 ALTER COLUMN id SET DEFAULT nextval('event_user_id_seq');


之前的数据，需要修改下，id位移到最大的
SELECT setval('event_user_id_seq', (SELECT MAX(id) FROM event_user) + 1);


INSERT INTO event_user (phone) VALUES (18612529003)
```