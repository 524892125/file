```javascript
import CryptoJS from "crypto-js";
import { JSEncrypt } from "jsencrypt";

export function ewq() {
    const publicKey = `-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA7DMoy4tJsvW65kUQNdNm
+/106Taj8yOMC8+Q4KP6EgU3tQ9OmSgs5QorzV43xr0ZQk7sYUXasHAorPe5rY8j
J5haMutbT5z8DlxJ4cGvoDz3dVyOYYpqfgIq2/jGbhuhkdF5L4ysX5NXOM1JzwvO
2LbU1W8c5VDyF7zeukiMFw05P0nlVCw3p0qfj0klGs6JWs5pUydvfc/lJQ+j9pX0
o/TS6hsbEh/CLm7xyXJmpFJg6l5Vq1fKVu037T2Nw7QGv9s490aZf1QG2B9bW6cW
w8zGCyNtDjJ+1LJjgLV7Mw6V25ApHL5st8YGVVGAqwhFfDoIibUHSFPKhGuhpawO
oQIDAQAB
-----END PUBLIC KEY-----`;

    const now = Math.floor(Date.now() / 1000); // 秒级时间戳
    const rand = Math.floor(Math.random() * 900 + 100).toString(); // 三位随机数
    const data = `${now}${rand}`;

    // 生成 AES key (32字节) 和 IV (16字节)
    const aesKey = CryptoJS.lib.WordArray.random(32); // 32 字节
    const iv = CryptoJS.lib.WordArray.random(16);     // 16 字节

    // AES-256-CBC 加密
    const encryptedData = CryptoJS.AES.encrypt(data, aesKey, {
        iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7,
    }).ciphertext.toString(CryptoJS.enc.Base64);

    // RSA 公钥加密 AES key + IV
    const encryptor = new JSEncrypt();
    encryptor.setPublicKey(publicKey);
    const keyIvCombined = CryptoJS.enc.Hex.stringify(iv) + CryptoJS.enc.Hex.stringify(aesKey); // IV + Key
    const encryptedKey = encryptor.encrypt(keyIvCombined); // 输出 base64

    return btoa(JSON.stringify({ key: encryptedKey, data: encryptedData }));
}

```

```java
private void checkToken(String token) throws Exception {
        // ① 解 Base64
        String jsonPayload = new String(Base64.getDecoder().decode(token), StandardCharsets.UTF_8);

        // ② 解析 JSON
        ObjectMapper mapper = new ObjectMapper();
        Map<String, String> payload = mapper.readValue(jsonPayload, Map.class);

        String encryptedKeyB64 = payload.get("key");
        String encryptedDataB64 = payload.get("data");
        log.info("encryptedKeyB64 {}", encryptedKeyB64);
        log.info("encryptedDataB64 {}", encryptedDataB64);

        byte[] encryptedKey = Base64.getDecoder().decode(encryptedKeyB64);
        byte[] encryptedData = Base64.getDecoder().decode(encryptedDataB64);

        // ③ 加载私钥
        String privateKeyPem = """
                -----BEGIN PRIVATE KEY-----
                MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQDsMyjLi0my9brm
                RRA102b7/XTpNqPzI4wLz5Dgo/oSBTe1D06ZKCzlCivNXjfGvRlCTuxhRdqwcCis
                97mtjyMnmFoy61tPnPwOXEnhwa+gPPd1XI5himp+Airb+MZuG6GR0XkvjKxfk1c4
                zUnPC87YttTVbxzlUPIXvN66SIwXDTk/SeVULDenSp+PSSUazolazmlTJ299z+Ul
                D6P2lfSj9NLqGxsSH8IubvHJcmakUmDqXlWrV8pW7TftPY3DtAa/2zj3Rpl/VAbY
                H1tbpxbDzMYLI20OMn7UsmOAtXszDpXbkCkcvmy3xgZVUYCrCEV8OgiJtQdIU8qE
                a6GlrA6hAgMBAAECggEARjOsZ9bVyEVlz+Pt/fl/rdy2n0wYrX6+tJH0Lvg9rpZz
                aLKMe1PoCAkeXLMoo753X/BiLEUdSvyC8mnMe4vD+JQ9Fs5B/OcdOU1vvhQZlWgZ
                an3gaZhAr4QIZgnKPFalDlhyitHmN5/suBq32bxaNaodlvQn4/ZLhgeiMT63uG+o
                9dPx+sFKOlnKjBeXT6km5g/VijGPJEoc3EYjzWGOdRg7reKQPeHkerHq3VgKDIeW
                mzYY7/+ONxkHI6Gsr8S9BIoC2SNZbSEMxXRbc91hclfJ5/7KJRVSf21id59X+KkG
                jYOoyNbVREo5k7Bq2wMGlnqgO6n52RnNvtx93BQh+wKBgQD+ncPi88v13OgKuj/i
                bW3UMMSsDklLsqSf73RtT8qzjh+47lSqpGruLYmpkBzLTTDen4TfXAzeQ9j4yde1
                gVuVLOvyA6jA9YOWnz72hnoZjqUR3c2xjziDECH5P7wc346jbAcMjcDf6Zcw0N8h
                kADuOGBtC9YjQrz9NtTEHZWaDwKBgQDte8W25uNQ8TcFcLkE3SU3ay0/4yg1KDj4
                OkCS6bmZYetoWhIgVMJ/lIrC0nlvaPUIQ9yHbUVwWOByulMNl8ze+7blfx+rJntm
                XXbQMUZ+tnuSFnh5KPAymjn6GAzbm96+Ex0FqE09Rv9OJGS45A3pMeTwr3Y96QjZ
                h7q/ozo8TwKBgQCBUZPaQ0UGXOql+C7WTAoKSbK6SI9FmTgv2yjhFDO5uqe1/6aU
                /Okqi4ptyro1L8FwcMjFwTTv9rnOsoWStF7Vh3lW9DDTwF7TM5KBF5AQRvjj+Cmu
                0zU6rAj1VT+v0oPZ0NZLs/uQPk4CBzQtEbzHQW8IM4jRY+YlHaI28We4VQKBgQDV
                e+iWrSQ3xT+y8kxApRQpp30761ZfwtLDwon+B4HC8pWObznQOqHF0qCS1mY30uBD
                F84NKBu+DQdn2zuCAq423Yzi7c5oKuXPdcGzEjjO+/hFsVGHiVe0BZSM0EXuvUYV
                FFWImm0k4sfrVSf+VXRz51hpTTI8IVrFQhCM6Y0WXQKBgHl7EYK47fpmkgdFPbx4
                ndGU1Qn4wkSyNAFNjT+mGIqzKTlpQNyIBeisoCc0GKefvrX4Mb50T/yQmXQ1iwi3
                cMIAyjL72L6TTlzaTAOhoEZMA6OoYpWK6x3qJr+mbs5My2B7hC7r1CxYTBQ2MEJI
                RTdYDaqIXzfCgkjmE8l2JaH9
                -----END PRIVATE KEY-----
                
                """;
        PrivateKey privateKey = CryptoUtil.loadPrivateKey(privateKeyPem);

        // ④ RSA 私钥解密得到 iv + aesKey (hex 字符串)
        byte[] decrypted = CryptoUtil.rsaDecryptOAEP(encryptedKey, privateKey);
        String hexCombined = new String(decrypted, StandardCharsets.UTF_8);

        // 前 32 字节为 IV，后 64 字节为 AES key (hex)
        byte[] iv = hexStringToByteArray(hexCombined.substring(0, 32));
        byte[] aesKey = hexStringToByteArray(hexCombined.substring(32));

        // ⑤ AES 解密
        String plainText = CryptoUtil.aesDecrypt(encryptedData, aesKey, iv);
        log.info("解密后的数据: {}", plainText);

        // ⑥ 校验时间戳
        long expire = 60; // 60 秒
        long timestamp = Long.parseLong(plainText.substring(0, 10));
        if (Math.abs(System.currentTimeMillis() / 1000 - timestamp) > expire) {
            throw new Exception("超时");
        }

        // ⑦ 去重逻辑
        String redisKey = "gm:java:request:" + plainText;
        Boolean success = redisTemplate.opsForValue().setIfAbsent(redisKey, plainText, expire, TimeUnit.SECONDS);
        if (Boolean.FALSE.equals(success)) {
            throw new Exception("重复请求");
        }
    }
```

```java
package com.ruoyi.web.controller.common;

import org.bouncycastle.jce.provider.BouncyCastleProvider;

import javax.crypto.Cipher;
import javax.crypto.spec.IvParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.KeyFactory;
import java.security.PrivateKey;
import java.security.Security;
import java.security.spec.PKCS8EncodedKeySpec;
import java.util.Base64;

public class CryptoUtil {

    static {
        // 注册 BouncyCastle 提供者支持 OAEP
        Security.addProvider(new BouncyCastleProvider());
    }

    /** 加载PKCS#8 私钥 */
    public static PrivateKey loadPrivateKey(String pem) throws Exception {
        String privateKeyPem = pem
                .replace("-----BEGIN PRIVATE KEY-----", "")
                .replace("-----END PRIVATE KEY-----", "")
                .replaceAll("\\s", "");
        byte[] keyBytes = Base64.getDecoder().decode(privateKeyPem);
        PKCS8EncodedKeySpec spec = new PKCS8EncodedKeySpec(keyBytes);
        KeyFactory kf = KeyFactory.getInstance("RSA");
        return kf.generatePrivate(spec);
    }

    /** RSA 私钥解密 (OAEP) */
    public static byte[] rsaDecryptOAEP(byte[] encrypted, PrivateKey privateKey) throws Exception {
        Cipher cipher = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        cipher.init(Cipher.DECRYPT_MODE, privateKey);
        byte[] ivAndKey = cipher.doFinal(encrypted);
        return ivAndKey;
//        Cipher cipher = Cipher.getInstance("RSA/ECB/OAEPWithSHA-1AndMGF1Padding", "BC");
//        cipher.init(Cipher.DECRYPT_MODE, privateKey);
//        return cipher.doFinal(encrypted);
    }

    /** AES-256-CBC 解密 */
    public static String aesDecrypt(byte[] cipherText, byte[] aesKey, byte[] iv) throws Exception {
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");
        SecretKeySpec keySpec = new SecretKeySpec(aesKey, "AES");
        IvParameterSpec ivSpec = new IvParameterSpec(iv);
        cipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);
        byte[] decrypted = cipher.doFinal(cipherText);
        return new String(decrypted, StandardCharsets.UTF_8);
    }
}

```